import jsy_render from './jsy_render.jsy'
export default bind_jsy_scanner

const rx_eol = /^[ \t]*$/
const rx_jsy_op_to_rx = /[@:.\/\\\(\)\{\}\[\]]/g

function bind_jsy_scanner(options={}) ::
  let {at_offside, keyword_offside} = options
  if null == at_offside ::
    at_offside = bind_jsy_scanner.at_offside
  if null == keyword_offside ::
    keyword_offside = bind_jsy_scanner.keyword_offside

  const rx_jsy_ops = new RegExp @
    at_offside
      .filter @ e => e.jsy_op
      .map @ e => e.jsy_op.replace @ rx_jsy_op_to_rx, '\\$&'
      .map @ e => `(?:^|[ \\t])${e}(?=$|[ \\t])`
      .join('|')
    'g'

  const scn_op = {}
  for const ea of at_offside ::
    scn_op[ea.jsy_op] = ea

  return jsy_scanner

  function jsy_scanner(offside_lines) ::
    if 'string' === typeof offside_lines ::
      offside_lines =
        javascript_scanner @
          offside_scanner @
            offside_lines

    const ctx_outer = {}
    for const ln of offside_lines ::
      if ! ln.blank ::
        jsy_expand_line(ln, ctx_outer)

      ln.t_content = jsy_render(ln)

    return offside_lines

  function _last_non_comment(ops) ::
    for let i = ops.length - 1; 0 <= i ; i-- ::
      if ! ops[i].op.startsWith('comment') ::
        return ops[i]

  function jsy_expand_line(ln, ctx_outer) ::
    const ops = ln.ops, new_ops = []
    const ctx = @{}
      ln
      __proto__: ctx_outer
      first_op: ops[0]
      last_op: _last_non_comment(ops)
    const emit = op => ::
      //console.dir @ {emit: op}, @{} colors: true
      new_ops.push(op)
    ln.ops = new_ops

    for const op of ops ::
      jsy_split_ops @ ctx, op, emit

    ctx_outer.in_kw = ctx.in_kw
    return ops

  function jsy_split_ops(ctx, op, emit) ::
    if 'src' !== op.op ::
      return emit(op)

    let c0=0, sz=op.sz
    let jsy_stack=[]

    if ctx.in_kw ::

    else if ctx.first_op === op ::
      // test for JSY keyword
      const m_kw = sz.match @ keyword_locator

      if m_kw ::
        let pos = c0 + m_kw[0].length
        emit @: op: 'src', c0, c1:pos, sz: m_kw[0]
        emit @: op: 'jsy_kw_open', c0, c1:pos, sz: ' ('
        jsy_stack.push @ ''
        ctx.in_kw = true

        // fixup c0 and sz for jsy operator parsing
        c0 = pos
        sz = ' '.repeat(c0) + sz.slice(c0)


    const is_first = ctx.first_op === op
    const is_last = ctx.last_op === op

    sz.replace @ rx_jsy_ops, (match, ...args) => ::
      const sz_line = args.pop()
      const pos = args.pop()

      if c0 < pos ::
        const jsy_op = match.replace(/[ \t]/g,'')
        const {pre, post} = scn_op[jsy_op]

        emit @: op: 'src', c0, c1:pos, sz: sz.slice(c0, pos)
        const is_eol = is_last && is_eol_match(sz_line, pos, match.length)

        if '::' === jsy_op && ctx.in_kw ::
          emit @: op: 'jsy_kw_close', c0: pos, c1: pos, sz: ` )`
          if '' === jsy_stack[0] :: jsy_stack.shift()
          ctx.in_kw = false

        emit @: op: 'jsy_op', c0: pos, c1: pos, sz: ` ${pre}`, pre, post, is_eol
        jsy_stack.push @ post

      c0 = pos + match.length

    if c0 < sz.length ::
      emit @: op: 'src', c0, c1:sz.length, sz: sz.slice(c0)

    if jsy_stack.length > 0 ::
      const end = ctx.ln.findBlockEnd()
      end.jsy_stack = [jsy_stack.shift()].concat @ end.jsy_stack || []
      
    if jsy_stack.length > 0 ::
      ctx.ln.jsy_stack = jsy_stack.concat @ ctx.ln.jsy_stack || []


function is_eol_match(sz, pos, len) ::
  if 'string' === typeof len :: len = len.length
  return rx_eol.test @ sz.slice @ pos+len

import offside_scanner from './offside_scanner.jsy'
import bindBasicScanner from './basic_scanner.jsy'
const javascript_scanner = bindBasicScanner @
  bindBasicScanner.javascript_scanners


const at_outer_offside = @[]
  @{} jsy_op: '::@', pre: "(", post: ")", nestInner: false, implicitCommas: false,
  @{} jsy_op: '::()', pre: "(", post: ")", nestInner: false, implicitCommas: false,
  @{} jsy_op: '::{}', pre: "{", post: "}", nestInner: false, implicitCommas: false,
  @{} jsy_op: '::[]', pre: "[", post: "]", nestInner: false, implicitCommas: false,
  @{} jsy_op: '::', pre: "{", post: "}", nestInner: false, implicitCommas: false,

const at_inner_offside = @[]
  @{} jsy_op: '@:', pre: "({", post: "})", nestInner: true, implicitCommas: true
  @{} jsy_op: '@#', pre: "([", post: "])", nestInner: true, implicitCommas: true,
  @{} jsy_op: '@()', pre: "{", post: "}", nestInner: true, implicitCommas: true,
  @{} jsy_op: '@{}', pre: "{", post: "}", nestInner: true, implicitCommas: true
  @{} jsy_op: '@[]', pre: "[", post: "]", nestInner: true, implicitCommas: true,
  @{} jsy_op: '@', pre: "(", post: ")", nestInner: true, implicitCommas: true,

const at_offside = [].concat @
  at_outer_offside
  at_inner_offside

const keyword_locator = /^([ \t]*)(if|while|catch|for await|for)(?=\s+[^(])/
const keyword_offside = /^([ \t]*)(if|while|catch|for await|for)\s+([^(][^:]*?)(\s::\s|\s::$|$)/

Object.assign @ bind_jsy_scanner, @{}
  at_offside
  at_outer_offside
  at_inner_offside
  keyword_offside
