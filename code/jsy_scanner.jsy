import jsy_renderer from './jsy_render.jsy'
export default bind_jsy_scanner

const rx_eol = /^[ \t]*$/
const rx_jsy_op_to_rx = /[@:.\/\\\(\)\{\}\[\]]/g

function bind_jsy_scanner(options={}) ::
  let {at_offside, keyword_offside} = options
  if null == at_offside ::
    at_offside = bind_jsy_scanner.at_offside
  if null == keyword_offside ::
    keyword_offside = bind_jsy_scanner.keyword_offside

  const rx_jsy_ops = new RegExp @
    at_offside
      .filter @ e => e.jsy_op
      .map @ e => e.jsy_op.replace @ rx_jsy_op_to_rx, '\\$&'
      .map @ e => `(?:^|[ \\t])${e}(?=$|[ \\t])`
      .join('|')
    'g'

  const scn_op = {}
  for const ea of at_offside ::
    scn_op[ea.jsy_op] = ea

  return jsy_scanner

  function jsy_scanner(offside_lines, options) ::
    if 'string' === typeof offside_lines ::
      offside_lines =
        javascript_scanner @
          offside_scanner @
            offside_lines

    const jsy_render_ln = jsy_renderer(options || {})

    const ctx_outer = {}
    for const ln of offside_lines ::
      if ! ln.blank ::
        jsy_expand_line(ln, ctx_outer)

      jsy_render_ln(ln)

    offside_lines.src_map = jsy_render_ln.src_map
    return offside_lines

  function _last_non_comment(ops) ::
    for let i = ops.length - 1; 0 <= i ; i-- ::
      if ! ops[i].op.startsWith('comment') ::
        return ops[i]

  function jsy_expand_line(ln, ctx_outer) ::
    const ops = ln.ops, new_ops = []
    const ctx = @{}
      __proto__: ctx_outer
      ln, jsy_stack: []
      first_op: ops[0]
      last_op: _last_non_comment(ops)
    const emit = op => :: new_ops.push(op)
    ln.ops = new_ops

    for const op of ops ::
      jsy_split_ops @ ctx, op, emit

    fixup_jsy_stack(ctx)
    ctx_outer.in_kw = ctx.in_kw

  function jsy_split_ops(ctx, op, emit) ::
    if 'src' !== op.op || rx_eol.test(op.sz) ::
      return emit(op)

    let c0=0, sz=op.sz, jsy_stack=ctx.jsy_stack

    if ctx.first_op === op ::
      if ! ctx.in_kw ::
        // look for JSY keyword
        const m_kw = sz.match @ keyword_locator

        if m_kw ::
          let pos = c0 + m_kw[0].length
          emit @: op: 'src', c0, c1:pos, sz: m_kw[0]
          emit @: op: 'jsy_kw_open', sz: ' ('
          jsy_stack.unshift @ ''
          ctx.in_kw = true

          // fixup c0 and sz for jsy operator parsing
          c0 = pos
          sz = ' '.repeat(c0) + sz.slice(c0)


    const is_last = ctx.last_op === op

    let is_eol
    sz.replace @ rx_jsy_ops, (match, ...args) => ::
      const sz_line = args.pop()
      const pos = args.pop()

      if c0 < pos ::
        const jsy_op = match.replace(/[ \t]/g,'')
        const {pre, post} = scn_op[jsy_op]

        emit @: op: 'src', c0, c1:pos, sz: sz.slice(c0, pos)
        is_eol = is_last && is_eol_match(sz_line, pos, match.length)

        if '::' === jsy_op && ctx.in_kw ::
          emit @: op: 'jsy_kw_close', sz: ` )`
          ctx.in_kw = false

        emit @: op: 'jsy_op', sz: ` ${pre}`, pre, post, is_eol
        jsy_stack.unshift @ post

      c0 = pos + match.length

    if c0 < sz.length && ! is_eol_match(sz, c0, 0) ::
      emit @: op: 'src', c0, c1:sz.length, sz: sz.slice(c0)
      is_eol = false

    ctx.is_eol = is_eol


function fixup_jsy_stack(ctx) ::
  let {ln, jsy_stack, is_eol} = ctx
  if jsy_stack.length < 0 :: return

  const end = ln.findBlockEnd()
  if is_eol ::
    end.jsy_stack = [].concat @ jsy_stack, end.jsy_stack || []
    return

  if jsy_stack.length > 0 ::
    end.jsy_stack = [jsy_stack.pop()].concat @ end.jsy_stack || []
    
  if jsy_stack.length > 0 ::
    ln.jsy_stack = jsy_stack.concat @ ln.jsy_stack || []


function is_eol_match(sz, pos, len) ::
  if 'string' === typeof len :: len = len.length
  return rx_eol.test @ sz.slice @ pos+len

import offside_scanner from './offside_scanner.jsy'
import bindBasicScanner from './basic_scanner.jsy'
const javascript_scanner = bindBasicScanner @
  bindBasicScanner.javascript_scanners


const at_outer_offside = @[]
  @{} jsy_op: '::@', pre: "(", post: ")", nestInner: false, implicitCommas: false,
  @{} jsy_op: '::()', pre: "(", post: ")", nestInner: false, implicitCommas: false,
  @{} jsy_op: '::{}', pre: "{", post: "}", nestInner: false, implicitCommas: false,
  @{} jsy_op: '::[]', pre: "[", post: "]", nestInner: false, implicitCommas: false,
  @{} jsy_op: '::', pre: "{", post: "}", nestInner: false, implicitCommas: false,

const at_inner_offside = @[]
  @{} jsy_op: '@:', pre: "({", post: "})", nestInner: true, implicitCommas: true
  @{} jsy_op: '@#', pre: "([", post: "])", nestInner: true, implicitCommas: true,
  @{} jsy_op: '@()', pre: "{", post: "}", nestInner: true, implicitCommas: true,
  @{} jsy_op: '@{}', pre: "{", post: "}", nestInner: true, implicitCommas: true
  @{} jsy_op: '@[]', pre: "[", post: "]", nestInner: true, implicitCommas: true,
  @{} jsy_op: '@', pre: "(", post: ")", nestInner: true, implicitCommas: true,

const at_offside = [].concat @
  at_outer_offside
  at_inner_offside

const keyword_locator = /^([ \t]*)(if|while|catch|for await|for)(?=\s+[^(])/
const keyword_offside = /^([ \t]*)(if|while|catch|for await|for)\s+([^(][^:]*?)(\s::\s|\s::$|$)/

Object.assign @ bind_jsy_scanner, @{}
  at_offside
  at_outer_offside
  at_inner_offside
  keyword_offside
